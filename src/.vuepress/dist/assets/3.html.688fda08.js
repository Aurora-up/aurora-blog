import{_ as t}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as e,c as a,e as d,a as r,f as c}from"./app.56b2977a.js";const n="/aurora-blog/assets/image-20221222210453436.af8c9053.png",l="/aurora-blog/assets/image-20221223170842311.703776da.png",i="/aurora-blog/assets/image-20221223171200266.2372352a.png",s={},o=r("p",null,"应用层协议 —— HTTP 协议",-1),h=c('<h2 id="http-协议的发展概述" tabindex="-1"><a class="header-anchor" href="#http-协议的发展概述" aria-hidden="true">#</a> HTTP 协议的发展概述</h2><p>HTTP 1.0 到 HTTP 3.0 的发展：</p><p><img src="'+n+'" alt="image-20221222210453436" loading="lazy"></p><ul><li>HTTP 1.0 对同一服务器的每个请求都需要单独的 TCP 连接。</li><li>HTTP 1.1 中 TCP 连接可以保持打开状态以供重用（持久连接），但它不能解决 HOL（行头）阻塞问题。</li></ul><div class="custom-container info"><p class="custom-container-title">HOL 阻塞</p><p>HOL 阻塞 - 当浏览器中允许的并行请求数用完时，后续请求需要等待前一个请求完成。</p></div><ul><li>HTTP 2.0 通过请求多路复用解决了 HOL 问题，从而消除了应用层的 HOL 阻塞，但是 HOL 阻塞仍然存在于传输层（TCP）中。</li></ul><div class="custom-container info"><p class="custom-container-title">HTTP Streams</p><p>在上图中可以看到，HTTP 2.0 引入了 “ HTTP Streams ” 的概念，其是对允许多个不同的 HTTP 请求多路复用到同一个 TCP 连接上的一种抽象，每个流不需要按照顺序去发送。</p></div><ul><li>HTTP 3.0 底层使用 QUIC 而不是 TCP 作为底层传输协议，从而消除了传输层中的 HOL 阻塞。</li></ul><div class="custom-container info"><p class="custom-container-title">QUIC协议</p><p>QUIC 基于 UDP，其将 “Streams” 作为一等公民引入传输层。QUIC Steams 共享相同的 QUIC 连接，因此不需要额外的握手和缓慢启动来创建新的 Stream，但 QUIC Streams 是独立交付的，因此在大多数情况下，一个 Stream 的数据包丢失不会影响其他的 Stream。</p></div><h2 id="http-请求" tabindex="-1"><a class="header-anchor" href="#http-请求" aria-hidden="true">#</a> HTTP 请求</h2><p>​ HTTP 协议的请求格式如下图所示：</p><p><img src="'+l+'" alt="image-20221223170842311" loading="lazy"></p><h3 id="常用请求方法" tabindex="-1"><a class="header-anchor" href="#常用请求方法" aria-hidden="true">#</a> 常用请求方法</h3><table><thead><tr><th style="text-align:center;">方法名</th><th style="text-align:center;">用法</th><th style="text-align:center;">备注</th></tr></thead><tbody><tr><td style="text-align:center;"><code>GET</code></td><td style="text-align:center;">获取资源</td><td style="text-align:center;">其没有请求体，但有请求参数，虽然请求参数可以向服务器传送信息，但是请求参数只能明文传输，有安全隐患</td></tr><tr><td style="text-align:center;"><code>POST</code></td><td style="text-align:center;">向服务器发送数据</td><td style="text-align:center;">没有请求参数，但有请求体，可以通过加密算法对请求体加密，相较于直接使用 <code>GET</code> 请求修改服务器中的数据更加安全</td></tr><tr><td style="text-align:center;"><code>PUT</code></td><td style="text-align:center;">向指定资源位置上传其最新内容</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;"><code>DELETE</code></td><td style="text-align:center;">请求服务器删除指定的内容</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;"><code>HEAD</code></td><td style="text-align:center;">获取报文首部</td><td style="text-align:center;">与 <code>GET</code> 方法一样，只是不返回报文主体部分，通常用于确认 <code>URI</code> 的有效性及资源更新的日期时间等</td></tr></tbody></table><h3 id="请求首部字段" tabindex="-1"><a class="header-anchor" href="#请求首部字段" aria-hidden="true">#</a> 请求首部字段</h3><table><thead><tr><th style="text-align:center;">首部字段名</th><th style="text-align:center;">说明</th></tr></thead><tbody><tr><td style="text-align:center;"><code>Accept</code></td><td style="text-align:center;">用户代理可处理的媒体类型</td></tr><tr><td style="text-align:center;"><code>Accept-Charset</code></td><td style="text-align:center;">优先的字符集</td></tr><tr><td style="text-align:center;"><code>Accept-Encoding</code></td><td style="text-align:center;">优先的内容编码</td></tr><tr><td style="text-align:center;"><code>Accept-Language</code></td><td style="text-align:center;">优先的语言(自然语言)</td></tr><tr><td style="text-align:center;"><code>Authorization</code></td><td style="text-align:center;">Web 认证信息</td></tr><tr><td style="text-align:center;"><code>Expect</code></td><td style="text-align:center;">期待服务器的特定行为</td></tr><tr><td style="text-align:center;"><code>Host</code></td><td style="text-align:center;">请求资源所在服务器</td></tr><tr><td style="text-align:center;"><code>If-Match</code></td><td style="text-align:center;">比较实体标记(ETag)</td></tr><tr><td style="text-align:center;"><code>If-Modified-Since</code></td><td style="text-align:center;">比较资源的更新时间</td></tr></tbody></table><h2 id="http-响应" tabindex="-1"><a class="header-anchor" href="#http-响应" aria-hidden="true">#</a> HTTP 响应<img src="'+i+'" alt="image-20221223171200266" loading="lazy"></h2><h2 id="uri" tabindex="-1"><a class="header-anchor" href="#uri" aria-hidden="true">#</a> URI</h2>',18);function g(x,y){return e(),a("div",null,[o,d(" more "),h])}const m=t(s,[["render",g],["__file","3.html.vue"]]);export{m as default};
