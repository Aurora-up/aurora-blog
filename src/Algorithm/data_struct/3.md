---
title: 二叉搜索树
category: 
  - 数据结构
tag: 
  - 树
  - 二叉搜索树
prev: ./2
next: ./4
---

「二叉搜索树 Binary Search Tree」

<!-- more -->

「二叉搜索树 Binary Search Tree」满足以下条件：

1. 对于根结点，左子树中所有结点的值 < 根结点的值 < 右子树中所有结点的值；
2. 任意结点的左子树和右子树也是二叉搜索树，即也满足条件 `1.` ；

![image-20221227222729075](./image/image-20221227222729075.png)

:::code-tabs#language

@tab rust#rust

```rust
/// 二叉搜索树结点
#[derive(Debug)]
pub struct TreeNode<T: Ord + Clone>{
	value: T,
	left: Option<Box<TreeNode<T>>>,
	right: Option<Box<TreeNode<T>>>,
}
impl<T: Ord + Clone> TreeNode<T> {
	/// 创建一个新结点
	pub fn new(val: T) -> Self {
		TreeNode { value: val, left: None, right: None }	
	}
}

/// 二叉搜索树
#[derive(Debug)]
pub struct BinarySearchTree<T: Ord + Clone> {
	/// 二叉搜索树根节点
	root: Option<Box<TreeNode<T>>>,
}

impl<T: Ord + Clone> BinarySearchTree<T>{
  /// 创建一颗空的二叉搜索树
	pub fn new() -> Self {
		BinarySearchTree { root: None }
	}
	/// 从结点值数组构建二叉搜索树
	pub fn from(&mut self,nodes: &mut Vec<Option<T>>) {
		nodes.sort();
		self.root = build_tree(nodes, 0, (nodes.len() - 1) as isize);
	}
}
/// 递归地构建二叉搜索树
fn build_tree<T: Ord + Clone>( nodes: &mut Vec<Option<T>>,begin: isize, end: isize) -> Option<Box<TreeNode<T>>>{
	if begin > end { return None; }
	let mut mid = (begin + end) / 2;
	let mut root = Some(Box::new(TreeNode::new(nodes[mid as usize].clone().unwrap())));
	root.as_mut().unwrap().left = build_tree(nodes, begin, mid - 1);
	root.as_mut().unwrap().right = build_tree(nodes, mid + 1, end);
	return root;
}
```

@tab java#java

```java
// 二叉搜索树结点
class TreeNode<T extends Comparable<T>> {
  public T value;             // 节点值
  public TreeNode<T> left;    // 左子结点
  public TreeNode<T> right;   // 右子结点

  public TreeNode(T value) {
    this.value = value;  
  }
}

class BinarySearchTree<T extends Comparable<T>> {
	private TreeNode<T> root;
 	/**
   * 构建二叉搜索树
   * @param nodes 原始无序数组 (存储的是结点中的 值 ,即 TreeNode.value )
   */
  public BinarySearchTree(T[] nodes) {
    Arrays.sort(nodes);
    this.root = buildTree(nodes, 0, nodes.length - 1);
  }
  
  /**
   * @return 二叉树的根结点
   */
  public TreeNode<T> getRoot() {
    return this.root;
  }
  
  /**
   * 根据有序数组构建二叉树搜索树
   * @param nodes 有序的结点数组
   * @param begin 结点数组起始索引
   * @param end   结点数组末尾索引
   * @return 二叉搜索树的根节点
   */
  public TreeNode<T> buildTree(T[] nodes, int begin, int end) {
    if (begin > end) return null;
    // nodes[mid] 作为根节点
    int mid = (begin + end) / 2;
    TreeNode<T> root = new TreeNode<>(nodes[mid]);
    // 递归构建左子树和右子树
    root.left = buildTree(nodes, begin, mid - 1);
    root.right = buildTree(nodes, mid + 1, end);
    return root;
  }
}
```

@tab c++#c++

```cpp

```

:::

## 二叉搜索树的操作

### 查找结点

给定目标结点 `node` ，可以根据二叉搜索树的性质来查找。声明一个结点 `cur` ，从二叉树的根结点 `root` 出发，循环比较结点值 `cur.value` 和 `node.value` 之间的大小关系.

- 若 `cur.value < node.value` ，说明目标结点在 `cur` 的右子树中，因此执行 `cur = cur.right` ；
- 若 `cur.value > node.value` ，说明目标结点在 `cur` 的左子树中，因此执行 `cur = cur.left` ；
- 若 `cur.value = node.value` ，说明找到目标结点，跳出循环并返回该结点即可；

:::tabs

@tab step1

![image-20221227224209336](./image/image-20221227224209336.png)

@tab step2

![image-20221227224245927](./image/image-20221227224245927.png)

@tab step3

![image-20221227224312600](./image/image-20221227224312600.png)

@tab step4

![image-20221227224343427](./image/image-20221227224343427.png)

:::

二叉搜索树的查找操作就像二分查找一样，每次折半。循环次数最多为二叉树的高度，**当二叉树平衡时**，时间复杂度为 $O(log_n)$ .

:::code-tabs#language

@tab rust#rust

```rust
impl<T: Ord + Clone> BinarySearchTree<T>{
  /// 查找结点值,
  pub fn search(&mut self, value: &T) -> bool {
    let mut cur = &self.root;
    while let Some(node) = cur {
      cur = match value.cmp(&node.value) {
        Ordering::Equal => return true,     // 已找到
        Ordering::Less => &node.left,       // 左子树中
        Ordering::Greater => &node.right,   // 右子树中
      }
    }
    false
  }
}
```

@tab java#java

```java
/**
 * 查找结点
 * @param node 查找的目标结点
 * @return 返回查找的目标结点
 */
public TreeNode<T> search(TreeNode<T> node) {
  TreeNode<T> cur = root;
  while (cur != null && node != null) {
    if (cur.value.compareTo(node.value) < 0)      // 目标结点的值大于根节点的值, 在右子树中
      cur = cur.right;
    else if (cur.value.compareTo(node.value) > 0) // 目标结点的值小于根节点的值, 在左子树中
      cur = cur.left;
    else           // 找到目标结点, 跳出循环
      break;
  }
  return cur;
}
```

@tab c++#c++

```cpp

```

:::





### 插入结点

给定一个待插入结点 `node` ，为了保持二叉搜索树 “左子树 < 根结点 < 右子树” 的性质，插入操作分为两步：

1. **查找插入位置：** 与查找操作类似，我们从根结点出发，根据当前结点值和 `node.value` 的大小关系循环向下搜索，直到越过叶结点（遍历到 $null$）时跳出循环；
2. **在该位置插入结点：** 将该结点放到查到的 $null$ 位置 ；

二叉搜索树不允许存在重复结点，否则将会违背其定义。因此若待插入结点在树中已经存在，则不执行插入，直接返回即可.

![image-20221227225855008](./image/image-20221227225855008.png)

为了插入结点，需要借助 **辅助结点 `pre`** 保存上一轮循环的结点，这样在遍历到 $null$ 时，我们也可以获取到其父结点，从而完成结点插入操作。

与查找结点相同，**当二叉树平衡时**，插入结点的时间复杂度为: $O(log⁡_n)$.

:::code-tabs#language

@tab rust#rust

```rust
impl<T: Ord + Clone> BinarySearchTree<T>{
	/// 插入结点值
	pub fn insert(&mut self, value: T) -> bool{
		insert_helper(&mut self.root, value)
	}
}
/// 插入辅助函数 (递归插入)
fn insert_helper<T: Ord + Clone>(tree: &mut Option<Box<TreeNode<T>>>, value:T ) -> bool {
	if let Some(node) = tree {
		let inserted = match value.cmp(&node.value) {
			Ordering::Equal => false,         // 结点已存在
			Ordering::Less => insert_helper(&mut node.left, value),    // 应插入左子树
			Ordering::Greater => insert_helper(&mut node.right, value),// 应插入右子树
		};
		inserted
	}else {                                  // 找到待插入结点的位置,将其插入
		*tree = Some(Box::new(TreeNode{
			value,
			left: None,
			right: None,
		}));
		true
	}
}
```

@tab java#java

```java
/**
 * 插入结点
 * @param node 需要被插入的结点
 * @return 被插入结点信息
 */
public TreeNode<T> insert(TreeNode<T> node) {
  if (this.root == null) return null;
  TreeNode<T> cur = this.root;
  TreeNode<T> pre = null;
  // 查找结点位置
  while (cur != null) {
    if (cur.value.compareTo(node.value) == 0) // 结点已经存在, 直接返回
      return null;
    pre = cur;                  // 记录当前结点, 便于后序的插入
    if (cur.value.compareTo(node.value) < 0)  // 插入位置在当前结点的右子树
      cur = cur.right;
    else                                      // 插入位置在当前结点的左子树
      cur = cur.left;
  }
  // 插入该节点
  if (pre.value.compareTo(node.value) < 0)
    pre.right = node;
  else
    pre.left = node;
  return node;
}
```

@tab c++#c++

```cpp

```

:::





### 删除结点

与插入结点一样，我们需要在删除操作后维持二叉搜索树的 “左子树 < 根结点 < 右子树” 的性质。首先，我们需要在二叉树中执行查找操作，获取待删除结点。根据待删除结点的**子结点数量**，删除操作需要分为三种情况：

1. **待删除结点的子结点数量 = $0$ .** 表明待删除结点是叶结点，直接删除即可。

![image-20221227230225366](./image/image-20221227230225366.png)

2. **待删除结点的子结点数量 = $1$ .** 将待删除结点替换为其子结点。

![image-20221227230333570](./image/image-20221227230333570.png)

3. **待删除结点的子结点数量 = $2$ .** 删除操作分为三步：
   1. 找到待删除结点在 **中序遍历序列** 中的下一个结点，记为 `next` ；
   2. 在树中递归删除结点 `next` ；
   3. 使用 `next` 替换待删除结点；

:::tabs

@tab setp1

![image-20221227232312859](./image/image-20221227232312859.png)

@tab setp2

![image-20221227232349026](./image/image-20221227232349026.png)

@tab setp3

![image-20221227232428289](./image/image-20221227232428289.png)

@tab setp4

![image-20221227232458486](./image/image-20221227232458486.png)

:::

:::code-tabs#language

@tab rust#rust

```rust
impl<T: Ord + Clone> BinarySearchTree<T>{
	/// 删除结点
	pub fn remove(&mut self, value: &T) -> bool {
		remove_helper(&mut self.root, value)
	}
}
/// 删除辅助函数
fn remove_helper<T: Ord + Clone>(tree: &mut Option<Box<TreeNode<T>>>, value: &T) -> bool {
	if let Some(node) = tree {
		let removed = match value.cmp(&node.value) {
			Ordering::Less => remove_helper(&mut node.left, value),
			Ordering::Greater => remove_helper(&mut node.right, value),
			Ordering::Equal => {          // 找到了需要删除的结点
				*tree = match (node.left.take(), node.right.take()) {
					(None, None) => None,                          // 删除叶子结点
					(Some(b) , None) | (None, Some(b)) => Some(b), // 删除只有一个叶子结点的结点
					(Some(left), Some(right)) => Some(merge(left, right)), // 删除有两个子结点的结点
				};
				return true;
			}
		};
		removed
	}else {
		false
	}
}
/// 将要被删除的结点替换为它的中序遍历前驱结点, 返回该节点
fn merge<T: Ord + Clone>(left: Box<TreeNode<T>>, right: Box<TreeNode<T>>) -> Box<TreeNode<T>> {
	let mut op_right = Some(right);
	// 寻找被删除结点的中序遍历前驱结点, 即其右子树中的最小值
	let mut root = take_min(&mut op_right).unwrap();
	root.left = Some(left);
	root.right = op_right;
	root
}
/// 获取最小值
fn take_min<T: Ord + Clone>(tree: &mut Option<Box<TreeNode<T>>>) -> Option<Box<TreeNode<T>>> {
	if let Some(mut node) = tree.take() {
		// 例如删除 4 , 寻找其右子树种的最小结点,即: 5
		//         4
		//       /   \
		//      2     6
		//     / \   / \
		//    1  3  5   7
		if let Some(min) = take_min(&mut node.left) {  // 右子树中最左端结点
			*tree = Some(node);
			Some(min)
		
		}
		// 例如删除 4 , 寻找其右子树种的最小结点,即: 6
		//         4
		//       /   \
		//      2     6
		//     / \   
		//    1  3  
		else {                       //右子结点
			*tree = node.right.take();     
			Some(node)
		}
	}else {
		None
	}
}
```

@tab java#java

```java
/**
 * 删除结点
 * @param node 需要被删除的结点
 * @return 被删除的结点的信息
 */
public TreeNode<T> remove(TreeNode<T> node) {
  if (this.root == null) return null;        // 树为空,直接返回
  TreeNode<T> cur = this.root;
  TreeNode<T> pre = null;
  while (cur != null) {
    if (cur.value == node.value)             // 找到待删除结点,跳出循环
      break;
    pre = cur;                               // 记录当前结点,便于后续删除
    if (cur.value.compareTo(node.value) < 0) // 待删除结点在当前节点的右子树中
      cur = cur.right;
    else                                     // 待删除结点在当前结点的左子树中
      cur = cur.left;
  }
  if (cur == null) return null;              // 待删除结点不存在
  // 待删除结点的 子结点数量 = 0 或 1
  if (cur.left == null || cur.right == null) {
    // 当子结点数量 = 0 / 1 时， child = null / 该子结点
    TreeNode<T> child = cur.left != null ? cur.left : cur.right;
    if (pre.left == cur) pre.left = child;
    else pre.right = child;
  }
  // 待删除结点数量 = 2
  else {
    // 获取中序遍历下 cur 的后继结点 next
    TreeNode<T> next = take_min(cur.right);
    T tmp = next.value;
    // 删除 next 结点
    remove(next);
    // 将 next 结点的值赋给待删除结点
    cur.value = tmp;
  }
  return cur;
}

/**
 * 获取最小结点
 * @param node
 * @return
 */
public TreeNode<T> take_min(TreeNode<T> node) {
  if (node == null) return null;
  while (node.left != null) {
    node = node.left;
  }
  return node;
}
```

@tab c++#c++

```cpp

```

:::

## 二叉搜索树的优势

|                     | 无序数组 | 有序数组  | 二叉搜索树 (平衡时) |
| :-----------------: | :------: | :-------: | :-----------------: |
|    查找指定元素     |  $O(n)$  | $O(logn)$ |      $O(logn)$      |
|      插入元素       |  $O(1)$  |  $O(n)$   |      $O(logn)$      |
|      删除元素       |  $O(n)$  |  $O(n)$   |      $O(logn)$      |
| 获取最小 / 最大元素 |  $O(n)$  |  $O(1)$   |      $O(logn)$      |

:::warning

虽然在平衡时二叉搜索树的各项效率较好，但是这仅限平衡时，而对于一般的二叉树，如果对其进行动态维护，那么二叉搜索树就会退化。

:::

## 二叉搜索树的退化

理想状态下的，希望二叉搜索树是 “左右平衡” 的，此时可以在 $O(log_n)$ 的时间复杂度下查找任意结点。

但是如果**动态**的在二叉搜索树中插入与删除结点，则可能导致二叉树退化为链表，此时**各种操作**的时间复杂度都会退化为 $O(n)$

![image-20230102120759666](./image/image-20230102120759666.png)

如下图所示，执行两步删除结点后，该二叉搜索树就会退化为链表。

![image-20230102122358130](./image/image-20230102122358130.png)

再比如，在以下完美二叉树中插入两个结点后，树严重向左偏斜，查找操作的时间复杂度也随之发生劣化。

![image-20230102122459746](./image/image-20230102122459746.png)



从动态维护二叉搜索树的退化来看，“平衡” 操作尤为重要。































