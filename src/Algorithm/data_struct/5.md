---
title: AVL树
category: 
  - 数据结构
tag: 
  - 树
  - AVL树
prev: ./4
next: ./6
---

「AVL 树」

<!-- more -->

在「[二叉搜索树 - 二叉搜索树的退化](./3.md)」中，可见二叉搜索树在动态维护中效率并不高。

G. M. Adelson-Velsky 和 E. M. Landis 在其 1962 年发表的论文 "An algorithm for the organization of information" 中提出了「AVL 树」。**论文中描述了一系列操作，使得在不断添加与删除结点后，AVL 树仍然不会发生退化**，进而使得各种操作的时间复杂度均能保持在 $O(log⁡n)$ 级别。

换言之，在频繁增删查改的使用场景中，AVL 树可始终保持很高的数据增删查改效率，具有很好的应用价值。

## AVL 树常见术语

「AVL 树」既是「二叉搜索树」又是「平衡二叉树」，同时满足这两种二叉树的所有性质，因此又被称为「平衡二叉搜索树」.

### 结点高度

在 AVL 树的操作中，需要获取结点「高度 Height」，所以给 AVL 树的结点类添加 `height` 变量。



:::code-tabs#language

@tab rust#rust

```rust

```

@tab java#java

```java
public class TreeNode<T extends Comparable<T>> implements Comparable<TreeNode<T>> {
  public T value;             // 节点值
  public int height;          // 结点高度
  public TreeNode<T> left;    // 左子结点
  public TreeNode<T> right;   // 右子结点
  
  public TreeNode(T value) {
    this.value = value;
  }
  @Override
  public int compareTo(TreeNode<T> node) {
    if (node.value instanceof String) {
      return String.valueOf(this.value).compareTo(String.valueOf(node.value));
    }
    if (node.value instanceof Integer) {
      return ((Integer) this.value) - ((Integer) node.value);
    }
    return 0;
  }
}
```

@tab c++#c++

```cpp

```

:::



「结点高度」是最远叶结点到该结点的距离，即走过的「边」的数量。需要特别注意，**叶结点的高度为 0 ，空结点的高度为 -1** 。封装两个工具函数，分别用于获取与更新结点的高度。

:::code-tabs#language

@tab rust#rust

```rust

```

@tab java#java

```java
class AVLTree<T extends Comparable<T>> {
  TreeNode<T> root;

  /**
   * 获取结点高度
   * @param node 结点信息
   * @return 结点高度
   */
  public int height(TreeNode<T> node) {
    // 空结点高度为 -1 ，叶结点高度为 0
    return node == null ? -1 : node.height;
  }

  /**
   * 更新结点高度
   * @param node
   */
  private void updateHeight(TreeNode<T> node) {
    // 结点高度等于最高子树高度 + 1
    node.height = Math.max(height(node.left), height(node.right)) + 1;
  }
}
```

@tab c++#c++

```cpp

```

:::

### 结点平衡因子

结点的「平衡因子 Balance Factor」是 **结点的左子树高度减去右子树高度**，并定义空结点的平衡因子为 0 。同样地，将获取结点平衡因子封装成函数，以便后续使用。



:::code-tabs#language

@tab rust#rust

```rust

```

@tab java#java

```java
/**
 * 获取该结点的平衡因子
 * @param node 结点
 * @return 结点的平衡因子
 */
public int balanceFactor(TreeNode<T> node) {
  // 空结点平衡因子为 0
  if (node == null) return 0;
  // 结点平衡因子 = 左子树高度 - 右子树高度
  return height(node.left) - height(node.right);
}
```

@tab c++#c++

```cpp

```

:::

:::info AVL 树性质

设平衡因子为 $f$ ，则一颗 AVL 树的任意结点的平衡因子皆满足 $-1≤f≤1$ .

:::

## AVL 树旋转

AVL 树的独特之处在于「旋转 Rotation」的操作，其可 **在不影响二叉树中序遍历序列的前提下，使失衡结点重新恢复平衡。** 换言之，旋转操作既可以使树保持为「二叉搜索树」，也可以使树重新恢复为「平衡二叉树」。

将平衡因子的绝对值 $>1$ 的结点称为「失衡结点」。根据结点的失衡情况，旋转操作分为 **右旋、左旋、先右旋后左旋、先左旋后右旋**.

### 右旋

如下图所示（结点下方为「平衡因子」），从底至顶看，二叉树中首个失衡结点是 **结点 3** 。聚焦在以该失衡结点为根结点的子树上，将该结点记为 `node` ，将其左子节点记为 `child` ，执行「右旋」操作。完成右旋后，该子树已经恢复平衡，并且仍然为二叉搜索树。

:::tabs

@tab step1

![image-20230102134355550](./image/image-20230102134355550.png)

@tab step2    

![image-20230102134453477](./image/image-20230102134453477.png)



@tab step3

![image-20230102134525630](./image/image-20230102134525630.png)



@tab step4

![image-20230102134555666](./image/image-20230102134555666.png)

:::

:::code-tabs#language

@tab rust#rust

```rust

```

@tab java#java

```java
/**
 * 右旋操作
 * @param node 失衡结点
 * @return 右转后该子树的根节点
 */
private TreeNode<T> rightRotate(TreeNode<T> node) {
  TreeNode<T> child = node.left;
  TreeNode<T> grandChild = child.right;
  // 以 child 为原点, 将 node 向左旋转
  child.right = node;
  node.left = grandChild;
  // 更新结点高度
  updateHeight(node);
  updateHeight(child);
  // 返回旋转后子树的根节点
  return child;
}
```

@tab c++#c++

```cpp

```

:::

### 左旋

类似地，如果将取上述失衡二叉树的“镜像”，那么则需要「左旋」操作。观察发现，**「左旋」和「右旋」操作是镜像对称的，两者对应解决的两种失衡情况也是对称的**。

![image-20230102135633720](./image/image-20230102135633720.png)

:::code-tabs#language

@tab rust#rust

```rust

```

@tab java#java

```java
/**
 * 左旋操作
 * @param node 失衡结点
 * @return 左旋后该子树的根节点
 */
private TreeNode<T> leftRotate(TreeNode<T> node) {
  TreeNode<T> child = node.right;
  TreeNode<T> grandChild = child.left;
  // 以 child 为原点将 node 向左旋转
  child.left = node;
  node.right = grandChild;
  // 更新结点高度
  updateHeight(node);
  updateHeight(child);
  // 返回旋转后子树的根节点
  return child;
}
```

@tab c++#c++

```cpp

```

:::              

### 先左后右

对于下图的失衡结点 3 ，**单一使用左旋或右旋都无法使子树恢复平衡**，此时需要「先左旋后右旋」，即先对 `child` 执行「左旋」，再对 `node` 执行「右旋」.

![image-20230102140323493](./image/image-20230102140323493.png)



### 先右后左

同理，取以上失衡二叉树的镜像，则需要「先右旋后左旋」，即先对 `child` 执行「右旋」，然后对 `node` 执行「左旋」。

![image-20230102140405760](./image/image-20230102140405760.png)

### 旋转的选择

下图描述的四种失衡情况与上述情况 一一对应，分别采用右旋、左旋、先右后左、先左后右的旋转组合。

![image-20230102140542501](./image/image-20230102140542501.png)

具体地，需要使用 **失衡结点的平衡因子、较高一侧子结点的平衡因子** 来确定失衡结点属于上图中的哪种情况。

| 失衡结点的平衡因子 | 子结点的平衡因子 | 应采用的旋转方法 |
| :----------------: | :--------------: | :--------------: |
|   $>0$ (左偏树)    |       $≥0$       |       右旋       |
|   $>0$ (左偏树)    |       $<0$       |   先左旋后右旋   |
|   $<0$ (右偏树)    |       $≤0$       |       左旋       |
|   $<0$ (右偏树)    |       $>0$       |   先右旋后左旋   |

:::code-tabs#language

@tab rust#rust

```rust

```

@tab java#java

```java
/**
 * 根据结点的平衡因子和子结点的平衡因子选择对应的旋转方式
 * @param node 失衡结点
 * @return 已经平衡的树的根节点
 */
private TreeNode<T> rotate(TreeNode<T> node) {
  // 获取结点 node 的失衡因子
  int balanceFactor = balanceFactor(node);
  // 左偏树
  if (balanceFactor > 1) {
    if (balanceFactor(node.left) >= 0) {
      // 右旋
      return rightRotate(node);
    } else {
      // 先左旋后右旋
      node.left = leftRotate(node.left);
      return rightRotate(node);
    }
  }
  // 右偏树
  if (balanceFactor < -1) {
    if (balanceFactor(node.right) <= 0) {
      // 左旋
      return leftRotate(node);
    } else {
      // 先右旋后左旋
      node.right = rightRotate(node.right);
      return leftRotate(node);
    }
  }
  // 已经旋转为平衡树, 直接返回
  return node;
}
```

@tab c++#c++

```cpp

```

:::

## AVL 树常用操作

### 插入结点

「AVL 树」的结点插入操作与「二叉搜索树」主体类似。不同的是，在插入结点后，从该结点到根结点的路径上会出现一系列「失衡结点」。所以，**我们需要从该结点开始，从底至顶地执行旋转操作，使所有失衡结点恢复平衡**。

:::code-tabs#language

@tab rust#rust

```rust

```

@tab java#java

```java
/**
 * 插入结点
 * @param node 待插入结点
 * @return 插入后 AVL 树的根节点
 */
public TreeNode<T> insert(TreeNode<T> node) {
  root = insertHelper(this.root, node);
  return root;
}

/**
 * 递归的插入结点 (辅助函数)
 * @param node   子树的根节点
 * @param i_node 待插入结点
 * @return 返回子树的根节点
 */
private TreeNode<T> insertHelper(TreeNode<T> node, TreeNode<T> i_node) {
  if (node == null) return i_node;         // 树为空, 插入结点直接作为根节点
  // 1. 查找插入位置，并插入结点
  if (i_node.value.compareTo(node.value) < 0)
    node.left = insertHelper(node.left, i_node);
  else if (i_node.value.compareTo(node.value) > 0)
    node.right = insertHelper(node.right, i_node);
  else
    return node;           // 重复结点不插入，直接返回
  updateHeight(node);      // 更新结点高度
  // 2. 执行旋转操作, 使子树重新恢复平衡
  node = rotate(node);
  return node;              // 返回子树的根节点
}
```

@tab c++#c++

```cpp

```

:::

### 删除结点

「AVL 树」删除结点操作与「二叉搜索树」删除结点操作总体相同。类似地，**在删除结点后，也需要从底至顶地执行旋转操作，使所有失衡结点恢复平衡**。

:::code-tabs#language

@tab rust#rust

```rust

```

@tab java#java

```java
/**
 * 删除结点
 * @param node 待删除结点
 * @return 删除后 AVL 树的根节点
 */
public TreeNode<T> remove(TreeNode<T> node) {
  root = removeHelper(this.root, node);
  return root;
}
/**
 * 递归地删除结点 (辅助函数)
 * @param node 子树的根节点
 * @param r_node 待删除结点
 * @return 返回子树的根节点
 */
private TreeNode<T> removeHelper(TreeNode<T> node, TreeNode<T> r_node) {
  if (node == null) return null;
  // 1. 查找结点, 并删除
  if (r_node.value.compareTo(node.value) < 0)
    node.left = removeHelper(node.left, r_node);
  else if (r_node.value.compareTo(node.value) > 0)
    node.right = removeHelper(node.right, r_node);
  else {
    if (node.left == null || node.right == null) {
      TreeNode<T> child = node.left != null ? node.left : node.right;
      if (child == null)    // 子结点数量 = 0 ，直接删除 node 并返回
        return null;
      else                  // 子结点数量 = 1 ，直接删除 node
        node = child;
    }else {
      // 子结点数量 = 2 ，则将中序遍历的下个结点删除，并用该结点替换当前结点
      TreeNode<T> next = inOrderNext(node.right);
      T tmp = next.value;
      node.right = removeHelper(node.right, new TreeNode<>(tmp));
      node.value = tmp;
    }
  }
  updateHeight(node);       // 更新结点高度
  // 2. 执行旋转操作，使该子树重新恢复平衡
  node = rotate(node);
  return node;              // 返回子树的根节点
}
/**
 * 获取待删除结点在中序遍历下的后继结点
 * @param node 待删除结点的右子结点
 * @return 待删除结点在中序遍历下的后继结点
 */
private TreeNode<T> inOrderNext(TreeNode<T> node) {
  if (node == null) return null;
  // 循环访问左子结点,直到叶结点时为最小结点,跳出循环
  while (node.left != null) {
    node = node.left;
  }
  return node;
}
```

@tab c++#c++

```cpp

```

:::

### 查找结点

:::code-tabs#language

@tab rust#rust

```rust

```

@tab java#java

```java
/**
 * 查找结点
 * @param node 带查找的结点
 * @return 目标结点
 */
public TreeNode<T> search(TreeNode<T> node) {
  TreeNode<T> cur = root;
  while (cur != null) {
    if (cur.value.compareTo(node.value) < 0)       // 目标结点在 root 的右子树中
      cur = cur.right;
    else if (cur.value.compareTo(node.value) > 0)  // 目标结点在 root 的左子树中
      cur = cur.left;
    else             // 找到目标结点，跳出循环
      break;
  }
  return cur;
}
```

@tab c++#c++

```cpp

```

:::













