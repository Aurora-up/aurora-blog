---
title : 请求, 响应
tag: 
  - springMVC
prev: ./1
next: ./3
---

请求、响应

<!-- more -->



# 基于注解的编程模型

## 控制器

SpringMVC 中的 MVC 模型中的 “C” 就是 Controller .

可以在某个类上声明 `@Controller` 作为 web Controller.

- [`@Controller`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/mvc/Controller.html) 

- [`@RestController`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/RestController.html) = `@Controllrt` + `@ResponseBody` 

:::info

`@RestController` 是一个组合注解，如上所示，其用于 RESTful 风格的 API 设计.传统的 web 应用与 前端之间不分离，所以需要 ModeView 模型，那么对于一个请求需要返回一个渲染好的页面，而 `@ResponseBody` 可以将方法的返回值直接作为响应正文，这样对于前后端分离的应用来说更加适用.

:::

```java
@RestController("/test")
public class HelloHandler {
  
  @GetMapping("/hello")             
  public String helloMVC(){
    return "Hello StringMVC";
  }
}
//  访问   ...../test/hello 路径响应 Hello StringMVC 
```

:::warning

`@Controller` 注解为 Spring 注解模型之一，在 Springboot 中不需要直接配置，因为其启动类上的注解是一个组合注解，其中包含下面的注解扫描方式，在 Spring 中使用需要将其配置在扫描 Bean 的包范围下：

:::

:::code-tabs

@tab java 配置类

```java {2}
@Configuration
@CompentScan("com.learn.Controller")
public class WebConfig {

    // ...
}
```

@tab Spring 启动类

```java {1}
@CompentScan("com.learn.Controller")
public class App {
	...
}
```

@tab XML

```xml {12}
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <context:component-scan base-package="org.example.web"/>

    <!-- ... -->

</beans>
```

:::







## 请求映射

在类上加上 控制器 之后就可以在该类中进行请求映射了。



[`@RequestMapping`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/RequestMapping.html) 注解用于将请求映射到控制器方法. 它具有各种**属性**,可以通过：

- (path) URL，对于 URL 的模式匹配两种，具体在 [这里](http://docs.jcohy.com/docs/spring-framework/5.3.22/html5/zh-cn/web.html#mvc-ann-requestmapping-uri-templates)
- (method) HTTP 方法，可指定的 Http 方法，具体在 [RequestMethod ](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/RequestMethod.html) 中
- (param) 请求参数，
- (headers) 请求头参数，
- (consumes，produces) 媒体类型，

进行匹配. 可以在**类级别**使用它来表示共享映射,或在**方法级**别上用于缩小到特定的请求映射范围.

封装 Http 请求方法的请求映射注解：

- `@GetMapping`
- `@PostMapping`
- `@PutMapping`
- `@DeleteMapping`
- `@PatchMapping`



> `consumes` 可以根据【**请求的** `Content-Type`】 缩小请求映射范围

```java {2}
@PostMapping(path = "/adduser", 
             consumes = "application/json") 
public void addUser(@RequestBody User user) {
    // ...
}
```

:::info

`consumes` 属性还支持否定表达式 ：

- 例如,`!text/plain` 表示除 `text/plain` 之外的任何内容类型.

也可以指定 [MediaType](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/MediaType.html) 中的常量类型作为限制:

- 例如, `MediaType.APPLICATION_JSON_VALUE` 

:::

:::warning

可以在类级别声明共享 `consumes` 属性. 但是,与大多数其他请求映射属性不同,在**类级别**使用时,会对方法级别`consumes` 属性**覆盖**而不是扩展.

:::



> `produces` 根据 `Accept` 请求头和控制器方法**生成的内容**类型列表来缩小请求映射

```java {2}
@GetMapping(path = "/users/{userId}", 
            produces = "application/json") 
@ResponseBody
public User getUser(@PathVariable String userId) {
    // ...
}
```

其性质同 `consumes` 一致。











# 函数式编程模型
